package explorer.feature

/**
 * Алгоритм Рабина - Карпа (Поиск по строки в строке)
 *
 * В данном примере мы используем хеш-функцию, чтобы быстро сравнивать подстроки в тексте и шаблоне.
 * Мы вычисляем хеш-значение для шаблона и первого окна текста, а затем сравниваем их. Если они совпадают,
 * мы проверяем совпадение путем сравнения отдельных символов.
 * Затем мы перемещаем окно текста на одну позицию вправо и повторяем процесс сравнения хеш-значений.
 * Если мы находим совпадение, мы добавляем индекс начала совпадающей подстроки в список результатов.
 *
 * Этот алгоритм имеет сложность O(n+m), где n - длина текста, а m - длина шаблона.
 */

fun rabinKarp(text: String, pattern: String): List<Int> {

    val result = mutableListOf<Int>() // Создаем список для хранения индексов найденных совпадений
    val prime = 101 // Выбираем случайное простое число для хеш-функции
    val n = text.length // Получаем длину текста
    val m = pattern.length // Получаем длину шаблона
    var patternHash = 0 // Хеш-значение шаблона
    var rollingHash = 0 // "Бегущее" хеш-значение окна текста
    var power = 1 // Значение, используемое при вычислении "бегущего" хеш-значения

    // Вычисляем хеш-значение шаблона и первого окна текста
    for (i in 0 until m) {
        patternHash = (patternHash * prime + pattern[i].code) % prime
        rollingHash = (rollingHash * prime + text[i].code) % prime
    }

    // Вычисляем power для последующих "бегущих" хеш-значений
    for (i in 1 until m) {
        power = (power * prime) % prime
    }

    // Сдвигаем окно текста на один символ вправо и сравниваем его с шаблоном
    for (i in 0..n-m) {
        // Если хеш-значение текущего окна текста и шаблона совпадают, проверяем совпадение путем сравнения отдельных символов
        if (rollingHash == patternHash) {
            var j = 0
            while (j < m && text[i+j] == pattern[j]) {
                j++
            }
            // Если все символы совпадают, добавляем индекс начала совпадающей подстроки в список результатов
            if (j == m) {
                result.add(i)
            }
        }
        // Вычисляем "бегущее" хеш-значение для следующего окна текста
        if (i < n-m) {
            rollingHash = (rollingHash - text[i].code * power % prime + prime) % prime
            rollingHash = (rollingHash * prime + text[i+m].code) % prime
        }
    }
    return result // Возвращаем список найденных совпадений
}